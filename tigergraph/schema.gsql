CREATE VERTEX Person (PRIMARY_ID id UINT, numFriends UINT, version UINT, versionHistory LIST<INT>, name STRING, emails SET<STRING>) WITH primary_id_as_attribute="TRUE"
CREATE VERTEX Post (PRIMARY_ID id UINT) WITH primary_id_as_attribute="TRUE"

CREATE UNDIRECTED EDGE KNOWS (FROM Person, TO Person, since UINT, versionHistory LIST<INT>)
CREATE DIRECTED EDGE LIKES (FROM Person, TO Post) WITH REVERSE_EDGE="LIKES_REVERSE"

CREATE GRAPH ldbc_acid(*)

USE GRAPH ldbc_acid
CREATE OR REPLACE QUERY insertPerson(UINT id, STRING name, SET<STRING> emails) {
  INSERT INTO Person (PRIMARY_ID, id, name, emails) VALUES (id, id, name, emails);
}

CREATE OR REPLACE QUERY atomicityC(UINT person1Id, UINT person2Id, STRING email, UINT since) {
  P1 = SELECT p FROM Person:p WHERE p.id == person1Id POST-ACCUM p.emails += email;
  INSERT INTO Person (PRIMARY_ID) VALUES (person2Id);
  INSERT INTO KNOWS (FROM, TO, since) VALUES (person1Id, person2Id, since);
}

CREATE OR REPLACE QUERY atomicityRB(UINT person1Id, UINT person2Id, STRING email) {
  P1 = SELECT p FROM Person:p WHERE p.id == person1Id POST-ACCUM p.emails += email;
  P2 = SELECT p FROM Person:p WHERE p.id == person2Id;
  IF P2.size() > 0 THEN
    ABORT;
  ELSE
    INSERT INTO Person (PRIMARY_ID) VALUES (person2Id);
  END;
}

CREATE OR REPLACE QUERY atomicityCheck() {
  SumAccum<UINT> @@nEmails;
  P = SELECT p FROM Person:p ACCUM @@nEmails += p.emails.size();
  P2 = SELECT p FROM Person:p WHERE p.name != "";
  PRINT P.size() as numPersons, P2.size() as numNames, @@nEmails as numEmails;
}

CREATE OR REPLACE QUERY initKnow() {
  INSERT INTO Person (PRIMARY_ID, versionHistory) VALUES (1, [0]);
  INSERT INTO Person (PRIMARY_ID, versionHistory) VALUES (2, [0]);
  INSERT INTO KNOWS (FROM, TO, versionHistory) VALUES (1, 2, [0]);
}

CREATE OR REPLACE QUERY g0(UINT person1Id, UINT person2Id, UINT transactionId) {
  tmp = SELECT t FROM Person:s -(KNOWS:e)- Person:t 
    WHERE s.id==person1Id AND t.id==person2Id
    ACCUM e.versionHistory += transactionId
    POST-ACCUM s.versionHistory += transactionId;
  P1 = SELECT t FROM Person:t 
    WHERE t.id==person2Id
    POST-ACCUM t.versionHistory += transactionId;
}

CREATE OR REPLACE QUERY g0check(UINT person1Id, UINT person2Id) {
  ListAccum<UINT> @@p1VersionHistory, @@kVersionHistory, @@p2VersionHistory;
  tmp = SELECT t FROM Person:s -(KNOWS:e)- Person:t 
    WHERE s.id==person1Id AND t.id==person2Id
    ACCUM @@p1VersionHistory += s.versionHistory,
    @@kVersionHistory += e.versionHistory,
    @@p2VersionHistory += t.versionHistory;
    PRINT @@p1VersionHistory AS p1VersionHistory,
      @@kVersionHistory AS kVersionHistory,
      @@p2VersionHistory AS p2VersionHistory;
}

CREATE OR REPLACE QUERY g1Init(UINT id, UINT version) {
  INSERT INTO Person (PRIMARY_ID, version) VALUES (id, version);
}

CREATE OR REPLACE QUERY g1aW(VERTEX<Person> personId, UINT sleepTime) {
  UINT a;
  DATETIME t0;
  P = {personId};
  // TigerGraph does not have sleep function
  t0 = now();
  WHILE datetime_diff(now(),t0) < sleepTime DO a += 1; END;
  UPDATE p FROM P:p SET p.version = 2;
  t0 = now();
  WHILE datetime_diff(now(),t0) < sleepTime DO a += 1; END;
  ABORT;
}

CREATE OR REPLACE QUERY g1bW(VERTEX<Person> personId, UINT sleepTime, UINT even, UINT odd) {
  UINT a;
  DATETIME t0;
  P = {personId};
  // TigerGraph does not have sleep function
  UPDATE p FROM P:p SET p.version = even;
  t0 = now();
  WHILE datetime_diff(now(),t0) < sleepTime DO a += 1; END;
  UPDATE p FROM P:p SET p.version = odd;
}

CREATE OR REPLACE QUERY g1R(VERTEX<Person> personId) {
  UINT pVersion;
  P = {personId};
  tmp = SELECT p FROM P:p ACCUM pVersion = p.version;
  PRINT pVersion;
}

INSTALL QUERY *